* The Unit Programming Language

The following is the specs for the Unit programming language, a lisp 
dialect. We aim to target programs that are closer to metal, with 
safety and flexibility in mind. This language is inspired by Clojure,
Typed Scheme, Common Lisp, Scala and Odin. The goal is to create a 
language that generally has enough speed to be able to accomplish
real time tasks such as terminal UI and desktop applications.

This language will be fairly imperative, and has elements of 
functional programming where it makes sense.

The name Unit comes from the Scala `Unit` type, representing nothing.

The following specs are work in progress and is not final.

** syntax 

  The Unit programming language has a syntax very similar to Clojure.

  @code
  (: inc [Num => Num])
  (defn inc [n]
    (+ 1 n))

  (defn core []
    (val x (i32 1))
    (println (inc x)))
  @end

*** namespace

  At the start of a file, a namespace must be provided. This system 
  is very similar to Clojure's.

  @code
  (ns foo)
  @end

  A namespace acts like a tree, allowing one to organize code 
  like a directory tree

  @code
  (ns foo.bar)
  @end

  To use functions or variables, import them 

  @code
  (ns foo 
    (:import [foo.bar :as bar :refer [f]]))
  @end

  In the above case, we impoet `foo.bar`, give it an alias 
  and dirctly import `f`.

  @code
  (f args)
  (bar/other-fn)
  (foo.bar/another-fn)
  @end

  As `f` is directly imported, one does not need to write the 
  namespace. One can call functions based on the raw name 
  of the namespace or the alias.
